/*
Messenger - wrapper around some client that sets up by-message communication, channels etc
don't makes any assumptions about underlying protocol
requires for client to have methods send(object) and disconnect(), and also have event (property) messageReceived
expect incoming and outcoming messages to be binary

paradigm is:
definition of channel is channel name and list of messages, each is message name and side byte (message is sent by server / client)
server-side message = message generated by server and processed by client; client-side message = guess what.

ping settings are:
	ping interval (interval between each new ping is sent)
	ping timeout (time between unanswered ping sent and connection is considered closed)
	ping storage pool
	ping_lower_filter_multiplier (0.7)
	ping_higher_filter_multiplier (1.3)
	client-time-derivation limit
	
each %interval% server forms and sends a ping package(with msecs of server-time)
client should append msecs of client-time to package and send it back (its named pong)
on pong received, server calculates following values:
	1. overall ping (current-server-time - sent-server-time)
	2. ping-to-client (current-server-time - sent-client-time)
	3. ping-to-server
	4. average ping-to-client:
		4.1 store last N pings-to-client values
		4.2 add last ping-to-client to the pool, remove oldest value from the pool
		4.3 calc average value
		4.4 without using values that are lower than ping_lower_filter_multiplier * average,
		4.5 without using values that are higher than ping_higher_filter_multiplier * average,
		4.6 calc average value and use it as average ping-to-client
	5. average ping-to-server:
		same as average ping-to-client
	6. client-time-derivation: (sent-client-time - current-server-time) - average-ping-to-client
if abs(client-time-derivation) is higher than limit, server sends a timeshift package with client-time-derivation value
	client should adjust its time by value mentioned in the package
if client does not receives pings more than ping_timeout time, it should also consider connection be closed

1. on client-side, channel and message model is defined
2. on server-side, same model is defined
3. after server-side definition, server creates IDs for the model and sends them to client
4. if client's definition of particular channel don't match server's, error is thrown. channel becomes unusable.
5. definition of the channel could not be altered while channel is in "defined" state.
6. channel definition state could be altered with two types of packages:
	"define" package; this package contains full definition of channel
	"undefine" package; this package notifies the client that the channel is not used anymore
7. right after connection, ping settings is sent

channels and messages are enumerated; first channel/message number is 1, not 0
there could be no more than 0xffffffff channels definition calls, so don't define a lot of channels
	(channel names/numbers are not reused; each time channel is defined, new channel id is generated, 
	even if same channel name was used before)
each channel could not have more than 0xff message types (in total of client- and server-side messages)
	
so, all the handlers of the messages on channel should be defined before receiving channel definition from server
it is done this way to explicitly prevent any partial data loss: all the messages are received or all are not received, no other options left

conclusion:
root package types are:
	1. define channel
	2. undefine channel
	3. ping
	4. pong
	5. timeshift

*/
aPackage('nart.net.message.messenger', () => {
	"use strict";
	
	var ClientSideMessenger = aRequire('nart.net.message.messenger.client'),
		ServerSideMessenger = aRequire('nart.net.message.messenger.server'),
		ByteManip = aRequire('nart.util.byte.manipulator'),
		Throw = aRequire('nart.util.throw');

	var Messenger = function(client, isServerSide){
		if(!(this instanceof Messenger)) return new Messenger(client, isServerSide)
	
		(isServerSide? ServerSideMessender: ClientSideMessender).call(this);

		this.client = client;
		
		this.onError = new Event(); // any error happened during request processing
		this.onDisconnect = new Event(); // connection closed by some reason
		this.onChannelDefined = new Event(); // server defines a new channel
		
		client.messageReceived.listen(d => {
			try {
				this.receive(new ByteManip(d.data));
			} catch(e){
				this.onError.fire({data: d.data, error: e})
			}
		});
	}
	
	Messenger.Channel = function(name, messenger){ 
		this.messenger = messenger; 
		this.name = name; 
		this.id = null; 
		this.server = {}; 
		this.client = {};
		
		if(name.length < 2) Throw.formatted('Failed to create channel definition: name "$1" is too short.', name);
	};
	Messenger.Channel.prototype = {
		isServerDefined: function(){ return this.id? true: false }
	};
	
	var failToCreateMessageWriter = Throw.formatted('Failed to create writer for message "$1" in channel "$2": $3.'),
		failToAddHandler = Throw.formatted('Failed to add handler "$1" with priority $2 to message "$3" on channel "$4": $5.');
	
	Messenger.Message = function(name, channel, isServerSide){ 
		this.name = name;
		this.isServerSide = isServerSide;
		this.id = null;
		this.channel = channel;
		this.handlers = [];
		
		if(name.length < 2) Throw.formatted('Failed to create message definition on channel "$2": name "$1" is too short.', name, channel.name);
		
		if(this.isOnSenderSide()){
			this.forceAddHandler(() => {
				Throw.formatted('Failed to handle incoming message "$1" on channel "$2": message received on wrong side.')(name, channel.name);
			}, 'wrong-message-side-error-throwing-handler', 0xffffffff)
		}
	}
	Messenger.Message.prototype = {
		isOnSenderSide: function(){
			return this.isServerSide === this.channel.messenger.isServerSide
		},
		// creates writer, calls callback to write the data and sends it
		writeAndSend: function(size, callback){
			var id = this.id, cid = this.channel.id;
				
			if(!cid) failToCreateMessageWriter(this.name, this.channelName, 'no channel id defined');
			if(!id) failToCreateMessageWriter(this.name, this.channelName, 'no message id defined');
			if(!this.isOnSenderSide()) failToCreateMessageWriter(this.name, this.channelName, 'tried to send message from wrong side');
			
			size += 6;
			var writer = ByteManip.alloc(size);
			writer.putByte(Messenger.Message.BasicTypes.data);
			writer.putUint(cid);
			writer.putByte(id);
			
			callback(writer, () => {
				var data = writer.getBuffer();
			
				if(data.length !== writer.getPosition()){
					Throw.formatted('Failed to send written message "$1" on channel "$2": expected buffer size not matches actual ($3 vs $4).')
						(this.name, this.channelName, size, data.length);
				}
				
				this.channel.messenger.sendArbitraryBinaryData(data);
			});
		},
		
		
		addHandler: function(hanlder, name, priority){
			if(this.isOnSenderSide()){
				failToAddHandler(name, priority, this.name, this.channel.name, 'could not handle incoming messages while on sender side')
			}
			
			this.forceAddHandler(handler, name, priority);
		},
		
		forceAddHandler: function(handler, name, priority){
			name = name || 'default';
			priority = priority || 0;
			
			if(name.length < 2) failToAddHandler(name, priority, this.name, this.channel.name, 'handler name is too short');
			if(priority < 0 || priority > 0xffffffff || typeof(priority) !== 'number'){
				failToAddHandler(name, priority, this.name, this.channel.name, 'incorrect priority value');
			}
			
			this.handlers.forEach(h => {
				if(h.name === name) failToAddHandler(name, priority, this.name, this.channel.name, 'handler with this name is already defined');
				if(h.priority === priority) failToAddHandler(name, priority, this.name, this.channel.name, 'handler with this priority is already defined');
			})
			
			this.handlers.push({handler: handler, name: name, priority: priority});
			this.handlers.sort((ha, hb) => ha.priority > hb.priority? -1: 1);
		},
		
		handle: function(message){
			for(var i = 0; i < this.handlers.length; i++){
				var isUnhandled = this.handlers[i](message);
				if(!isUnhandled) return;
			}
			
			Throw.formatted('Failed to handle message "$1" on channel "$2": all the handlers failed to handle the message.', this.name, this.channel.name);
		}
	}
	
	Messenger.Message.BasicTypes = {
		data: 0x00,
		
		ping: 0x01,
		pong: 0x02,
		
		timeshift: 0x03,
		
		defineChannel: 0x04,
		undefineChannel: 0x05
	}
	
	Messenger.prototype = {
		defineChannel: (channelDefinitionObject, hanldersName, handlersPriority) => { /* ...? */ },
		
		getChannels: () => {
			/* channels: {channel_name: channel} */
		},
		
		// better not use it directly
		sendArbitraryBinaryData: data => this.client.send(data)
	}
	
	return Messenger;

});