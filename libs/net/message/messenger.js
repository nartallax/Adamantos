/*
Messenger - wrapper around some client that sets up by-message communication, channels etc
don't makes any assumptions about underlying protocol
requires for client to have methods send(object) and disconnect(), and also have event (property) messageReceived
expect incoming and outcoming messages to be binary

paradigm is:
definition of channel is channel name and list of messages, each is message name and side byte (message is sent by server / client)
server-side message = message generated by server and processed by client; client-side message = guess what.

DISCLAIMER: some of these features are planned, but not implemented
the reason is i've have seen no uses for the features
for example, avg ping is not calculated; timeshift packages are also not used

ping settings are:
	ping interval (interval between each new ping is sent)
	ping timeout (time between unanswered ping sent and connection is considered closed)
	ping storage pool
	ping_lower_filter_multiplier (0.7)
	ping_higher_filter_multiplier (1.3)
	client-time-derivation limit
	
each %interval% server forms and sends a ping package(with msecs of server-time)
client should append msecs of client-time to package and send it back (its named pong)
on pong received, server calculates following values:
	1. overall ping (current-server-time - sent-server-time)
	2. ping-to-client (current-server-time - sent-client-time)
	3. ping-to-server
	4. average ping-to-client:
		4.1 store last N pings-to-client values
		4.2 add last ping-to-client to the pool, remove oldest value from the pool
		4.3 calc average value
		4.4 without using values that are lower than ping_lower_filter_multiplier * average,
		4.5 without using values that are higher than ping_higher_filter_multiplier * average,
		4.6 calc average value and use it as average ping-to-client
	5. average ping-to-server:
		same as average ping-to-client
	6. client-time-derivation: (sent-client-time - current-server-time) - average-ping-to-client

if abs(client-time-derivation) is higher than limit, server sends a timeshift package with client-time-derivation value
	client should adjust its time by value mentioned in the package
if client does not receives pings more than ping_timeout time, it should also consider connection be closed

1. on client-side, channel and message model is defined
2. on server-side, same model is defined
3. after server-side definition, server creates IDs for the model and sends them to client
4. if client's definition of particular channel don't match server's, error is thrown. channel becomes unusable.
5. definition of the channel could not be altered while channel is in "defined" state.
6. channel definition state could be altered with two types of packages:
	"define" package; this package contains full definition of channel
	"undefine" package; this package notifies the client that the channel is not used anymore
7. right after connection, ping settings is sent

channels and messages are enumerated; first channel/message number is 1, not 0
there could be no more than 0xffffffff channels definition calls, so don't define a lot of channels
	(channel names/numbers are not reused; each time channel is defined, new channel id is generated, 
	even if same channel name was used before)
each channel could not have more than 0xff message types (in total of client- and server-side messages)
	
so, all the handlers of the messages on channel should be defined before receiving channel definition from server
it is done this way to explicitly prevent any partial data loss: all the messages are received or all are not received, no other options left

*/
aPackage('nart.net.message.messenger', () => {
	"use strict";
	
	var ByteManip = aRequire('nart.util.byte.manipulator'),
		Event = aRequire('nart.util.event'),
		LimitedQueue = aRequire('nart.util.queue.limited'),
		Channel = aRequire('nart.net.message.channel'),
		Message = aRequire('nart.net.message.message');

	var getHeartbeatConfig = base => {
		base = base || {};
		
		base.interval || (base.interval = 1000);
		base.timeout || (base.timeout = base.interval * 10);
		base.poolSize || (base.poolSize = 10);
		base.lowerFilter || (base.lowerFilter = 0.5);
		base.higherFilter || (base.higherFilter = 1.5);
		base.allowedTimeDerivation || (base.allowedTimeDerivation = 250);
		
		return base;
	}
		
	var Messenger = function(client, isServerSide, heartbeatConfig){
		if(!(this instanceof Messenger)) return new Messenger(client, isServerSide)
	
		this.ping = {
			toClient: 0,
			toServer: 0
		};

		
		this.client = client;
		this.isServerSide = isServerSide;
		this.isConnected = true;
		
		this.channels = {};
		this.channelIdNameMap = {};
		this.channelId = 1;
		
		// any error that is not related with BAD usage of messenger: network errors etc
		// something that should not be thrown directly and something you may want to log instead of handling it with catch
		this.onError = new Event(); 
		this.onDisconnect = new Event(); // connection closed by some reason
		this.onChannelDefined = new Event(); // server defines a new channel
		this.onChannelUndefined = new Event(); // guess what
		this.onStatsUpdate = new Event(); // channel stats (i.e. ping values) are updated
		
		client.messageReceived.listen(d => {
			try {
				this.receive(new ByteManip(d.data));
			} catch(e){
				this.onError.fire({data: d.data, error: e})
				throw e;
			}
		});
		
		this.onChannelDefined(e => {
			var channel = e.data.channel,
				serverMap = e.data.serverMap,
				clientMap = e.data.clientMap;
				
			this.channelIdNameMap[channel.id] = channel.name;
				
			if(this.isServerSide){
				this.sendChannelDefinitionPackage(channel.name, channel.id, serverMap, clientMap);
			} /* else we just don't process the event; we already have received all required data */
		});
		
		this.onChannelUndefined(e => {
			var channel = e.data.channel,
				id = e.data.id;
			
			delete this.channelIdNameMap[id];
			
			if(this.isServerSide){
				this.sendChanneldUndefinitionPackage(id);
			}
		});
		
		this.isServerSide && this.setupHeartbeat(getHeartbeatConfig(heartbeatConfig));
	}
	
	var readDefinitionData = data => {
		var readSide = () => {
			var len = data.getByte(), side = {};
			
			while(len-->0){
				var id = data.getByte(), name = data.getString();
				side[name] = id;
			}
			
			return side;
		}
		
		return {
			id: data.getUint(),
			name: data.getString(),
			server: readSide(),
			client: readSide()
		}
	}
	
	var readHeartbeatConfig = bytes => ({
		interval: bytes.getUint(),
		timeout: bytes.getUint(),
		poolSize: bytes.getUint(),
		lowerFilter: bytes.getUint() / 0xffff,
		higherFilter: bytes.getUint() / 0xffff,
		allowedTimeDerivation: bytes.getUint()
	});
	
	Messenger.prototype = {
		// def: {name: "name", server: {msgA:() => {...}, ...}, client: {msgB: () => {...}, ...}}
		createChannel: function(channelDef, handlerName, handlerPriority, noAutodef){
			var channel = new Channel(channelDef.name, this);

			var defineSide = (def, isServer) => {
				Object.keys(def).forEach(name => {
					var msg = new Message(name, channel, isServer);
					channel.addMessage(msg);
					
					if(isServer !== this.isServerSide){
						var handler = def[name];
						msg.addHandler(handler, handlerName, handlerPriority);
					}
				})
			}
			
			defineSide(channelDef.server, true);
			defineSide(channelDef.client, false);
			
			(!noAutodef) && this.isServerSide && setTimeout(() => channel.define(), 1);
			
			return this.channels[channel.name] = channel;
		},
		
		generateChannelId: function(){
			return this.channelId++;
		},
		
		getDataWriter: function(channelId, messageId, payloadSize){
			var writer = ByteManip.alloc(payloadSize + 6);
			writer.putByte(basicMessageTypes.data);
			writer.putUint(channelId);
			writer.putByte(messageId);
			return writer;
		},
		
		// better not use it directly
		sendArbitraryBinaryData: function(data){ this.client.send(data) },
		
		sendChannelDefinitionPackage: function(name, id, serverMap, clientMap){
			var byteSize = 1 + 4 + ByteManip.stringSize(name)
				+ 1 + Object.keys(serverMap).map(name => 1 + ByteManip.stringSize(name)).reduce((a, b) => a + b, 0)
				+ 1 + Object.keys(clientMap).map(name => 1 + ByteManip.stringSize(name)).reduce((a, b) => a + b, 0);
				
			var bytes = ByteManip.alloc(byteSize),
				msgCount = Object.keys(clientMap) + Object.keys(serverMap);
			
			if(msgCount > 0xfe){
				fail.formatted('Could not generate definition for channel "$1": too many messages defined (max: $2, have: $3)', 'TOO_MANY_MESSAGES')
					(this.name, 0xfe, msgCount);
			}
			
			bytes.putByte(basicMessageTypes.defineChannel);
			bytes.putUint(id);
			bytes.putString(name);
			
			bytes.putByte(Object.keys(serverMap).length);
			Object.keys(serverMap).forEach(name => (bytes.putByte(serverMap[name]), bytes.putString(name)));
			bytes.putByte(Object.keys(clientMap).length);
			Object.keys(clientMap).forEach(name => (bytes.putByte(clientMap[name]), bytes.putString(name)));
			
			this.sendArbitraryBinaryData(bytes.getBuffer());
		},
		
		csendChannelUndefinitionPackage: function(id){
			var bytes = ByteManip.alloc(1 + 4);
			
			bytes.putByte(basicMessageTypes.undefineChannel);
			bytes.putUint(id);
			
			this.sendArbitraryBinaryData(bytes.getBuffer());
		},
		
		deferHeartbeatDisconnect: function(){
			this.heartbeatDisconnectHandle && clearTimeout(this.heartbeatDisconnectHandle);
			this.heartbeatDisconnectHandle = setTimeout(() => ((this.heartbeatDisconnectHandle = null), this.disconnect()), this.heartbeatConfig.timeout);
		},
		
		setupHeartbeat: function(config){
			if(this.heartbeatSendHandle){
				fail.formatted('Failed to setup heartbeat: heartbeat already set up.', 'DUPLICATE_HEARTBEAT_SETUP')();
			}
			this.heartbeatSendHandle = true;
			
			this.heartbeatSendHandle = null; // handle for interval of heartbeat package sending
			this.heartbeatDisconnectHandle = null; // handle for timeout of disconnect after heartbeat lost
			this.heartbeatConfig = config;
			this.deferHeartbeatDisconnect();
			
			if(this.isServerSide){
				this.sendHeartbeatSetupPackage(this.heartbeatConfig);
				this.heartbeatSendHandle = setInterval(() => this.sendPingPackage(), this.heartbeatConfig.interval);
				setImmediate(() => this.sendPingPackage());
			}
		},
		
		sendHeartbeatSetupPackage: function(conf){
			var bytes = ByteManip.alloc(1 + (4 * 6));
			
			bytes.putByte(basicMessageTypes.heartbeatConfig);
			
			bytes.putUint(conf.interval);
			bytes.putUint(conf.timeout);
			bytes.putUint(conf.poolSize);
			bytes.putUint(conf.lowerFilter * 0xffff);
			bytes.putUint(conf.higherFilter * 0xffff);
			bytes.putUint(conf.allowedTimeDerivation);
			
			this.sendArbitraryBinaryData(bytes.getBuffer());
		},
		
		sendPingPackage: function(){
			var bytes = ByteManip.alloc(1 + 8 + 4 + 4 + 4 + 4);
				
			bytes.putByte(basicMessageTypes.ping);
			bytes.putUlong(new Date().getTime());
			bytes.putUint(this.ping.toClient);
			bytes.putUint(this.ping.toServer);
			
			this.sendArbitraryBinaryData(bytes.getBuffer());
		},
		
		processPing: function(bytes){ 
			this.deferHeartbeatDisconnect();
			this.sendPongPackage(bytes.getUlong());
			this.adjustPingStatsWith(bytes.getUint(), bytes.getUint());
		},
		
		sendPongPackage: function(serverTime){
			var bytes = ByteManip.alloc(1 + 8 + 8);
			
			bytes.putByte(basicMessageTypes.pong);
			bytes.putUlong(serverTime);
			bytes.putUlong(new Date().getTime());
			
			this.sendArbitraryBinaryData(bytes.getBuffer());
		},
		
		processPong: function(bytes){
			this.deferHeartbeatDisconnect();
			
			var sendTime = bytes.getUlong(),
				clientTime = bytes.getUlong(),
				nowTime = new Date().getTime();
				
			this.adjustPingStatsWith(clientTime - sendTime, nowTime - clientTime)
		},
		
		adjustPingStatsWith: function(delayToClient, delayToServer){
			this.ping.toClient = delayToClient;
			this.ping.toServer = delayToServer;
			this.onStatsUpdate.fire(this.ping);
		},
		
		getChannelOrThrow: function(id){
			var channel = this.channels[this.channelIdNameMap[id]];
				
			if(!channel){
				fail.formatted('Failed to handle message: have no channel with ID $1.', 'ABSENT_DEFINITION')(id);
			}
			
			return channel;
		},
		
		readGetChannelOrThrow: function(data){ return this.getChannelOrThrow(data.getUint()) },
		
		disconnect: function(){
			this.isConnected = false;
			this.client.disconnect();
			
			this.heartbeatDisconnectHandle && clearTimeout(this.heartbeatDisconnectHandle);
			this.heartbeatSendHandle && clearInterval(this.heartbeatSendHandle);
			
			this.onDisconnect.fire();
		},
		
		receive: function(data){
			var basicType = data.getByte();
			
			switch(basicType) {
				case basicMessageTypes.data:
					return this.readGetChannelOrThrow(data).handle(data);
				case basicMessageTypes.ping:
					if(this.isServerSide) failBasicOnWrongSide('ping');
					return this.processPing(data);
				case basicMessageTypes.pong:
					if(!this.isServerSide) failBasicOnWrongSide('pong');
					return this.processPong(data);
				case basicMessageTypes.defineChannel:
					if(this.isServerSide) failBasicOnWrongSide('define_channel');
					var def = readDefinitionData(data);
					return this.channels[def.name].setDefinition(def.id, def.server, def.client);
				case basicMessageTypes.heartbeatConfig:
					if(this.isServerSide) failBasicOnWrongSide('heartbeat_config');
					return this.setupHeartbeat(readHeartbeatConfig(data))
				case basicMessageTypes.undefineChannel:
					if(this.isServerSide) failBasicOnWrongSide('undefine_channel');
					return this.readGetChannelOrThrow(data).undefine();
				default:
					fail.formatted('Failed to process the message: unknown type code $1.', 'UNKNOWN_BASIC_MESSAGE_TYPE')(basicType);
					
			}
		}
	}
	
	var basicMessageTypes = Messenger.BasicTypes = {
		data: 0x00,
		
		ping: 0x01,
		pong: 0x02,
		heartbeatConfig: 0x03,
		
		timeshift: 0x04,
		
		defineChannel: 0x05,
		undefineChannel: 0x06
	}
	
	return Messenger;

});